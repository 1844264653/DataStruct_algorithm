### 剑指offer 56 - ii. 数组中数字出现的次数 ii - 有限状态自动机

题目详情：数组中除了一个数字只出现一次之外，其他数字都出现了三次，找出这个只出现一次的数字

```markdown
输入：[3,4,3,3,]
输出：4
输入：[9,1,7,9,7,9,7]
输出：1
```

这题调用api counter 一步就可，实际上，我们可以实现这么一个counter

不过这题要实现的counter 更加简单一点，只要求最少出现的那个，而且限制了其他数字出现三次



#### 有限状态自动机

原则方法理解：把数组中所有的数字的二进制表示的每一位加起来，如果某一位的和可以被n（这题是3）整除，那么那个只出现一次的数字二进制表示中对应的那一位，是0， 否则是1.（因为其他的一定出现3次，被3整除了）



所有的二进制位运算的规则都相同，所以只需要考虑一位就可以，既然是被3整除，那所有数字的某个二进制位1的个数，有三种状态：0，1，2

- 初始状态：0
- 当前状态0，出现1次（输入二进制1），加1 ：1
- 当前无论什么状态，出现0次（输入二进制0），无变化：保持本身状态
- 当前状态1，输入二进制1， 加1: 2
- 当前状态2， 输入二进制1，加1: 回到初始状态 0

状态表：

| 状态\输入 | 0    | 1    |
| :-------: | ---- | ---- |
|     0     | 0    | 1    |
|     1     | 1    | 1    |
|     2     | 2    | 0    |

转换成二进制表示：

```markdown
异或运算：(任何数和0异或不变，和1异或等价于直接求反) x^0 = x   x^1=~x
与运算：x&0=0  x&1=x
```

因为一个二进制位只能表示 0 1 两个状态，2无法用一位表示，所以我们要用两位二进制来表示3个状态，00，01，10，那么每个二进制有两个状态，设置为two，one，初始状态都是0

由于是两位，所以过程稍微更复杂一点

分情况列出状态二进制表示two one：

| 状态\输入 | 0    | 1    |
| :-------: | ---- | ---- |
|    0 0    | 0 0  | 0 1  |
|    0 1    | 0 1  | 1 0  |
|    1 0    | 1 0  | 0 0  |

归类计算表达式（状态转换方程）：

计算one的下一个状态，标记公式为**next(one)**：

- 当two=0，看第一二行
  - 输入0，one=one不变
  - 输入1，one=～one 取反
  - 完全符合异或运算

**上述two=0规律，one符合异或运算：one = one^n**

- 当two=1，看最后一行
  - one只有0的初始情况，且无论输入0还是1，one=0

**上述two=1规律，one始终是0： one=0** 

**二者结合：one不仅和输入有关系，还和two有关系，有一点很明确，two=1，one一定有one=0，这种情况，只能和0做&运算能达到**：

```python
two = 1
one = one & 0
```

**two=0时候：one=one^n, 也可以写成  one=one^n&1**

```python
two = 0
one = one ^ n & 1
```

**我们看到做与运算的这个 0，1 的状态，和我们控制的变量two 刚好相反**：

```python
one = one & ~two
one = one ^ n & ~two
由于最后一步two是确定的跟着走，第一个公式为了和第二个公式合并，也加上异或，反正&运算之后都等于0

one = one ^ n & ~two
```



同理计算two的下一个状态，标记为**next(two)**

**two的值依赖one的值进行计算**

- 当one=0，第一行和第三行
  - 输入0，two不变：two = two，按照经验写成异或 two = two ^ 0 或者？ two & ～one
  - 输入1，00 =>01，10 => 00,这里可以看到one是有状态转换的
    - 第一行，one由于0变成了1，two=0不变 ，two = two 或者 two & two & next(one)
    - 第三行，one由于0变成了0，回到初始状态0, two = ~two 或者 two = two ^ 1 

**输入1:也就是说two总是会依赖到one的变化**：

```python
one = 0
# 输入0
two = two ^ n or tow & ~one or two ^ n & ~one
# 输入1
two = two & next(one) or two ^ n & next(one)
# next(one)函数代入
two = two ^ n & one ^ n & ~two = ～two & ~one & ~two = ~two & ~ one = ~two & ~one

# 这两种情况合并
～two = two^1 
# 所以
two = two ^ n & ~one
```

- 当one=1，看第二行
  - 输入0，不变，two=two&1 或者 two ^ 0  
  - 输入1，取反，two=～two 或者 two^1

```python
one=1
# 输入0 不变
two = two = two ^ 0 = two ^ n = two ^ n & ~one # 后面随便加都行，因为two本身是0， 后&运算为了合并公式
# 输入1  01 ==>  10 依赖了one的变化
two = ～two = two ^ n & next(one) = two ^ n & one ^ n & ~two = ~two & ~one & ~two = ~two & ~one = two ^ n & ~one
```



####  得到表达式

- one = one ^ n & ~two
- Two = two ^ n & ~one

其实依赖one的变化求two的值，状态其实只落后了一个转换（联动的），所以两种状态转换是等价的：若使用计算后的新one，则可以通过相同的公式计算two（所以可以求出一个之后，替换位置即可）



整体代码：

```python
class Solution:
  def singleNumber(self, nums:List[int]) -> int :
    # 一共需要两个位置记录为
    one,two = 0,0 # 初始化00
    for num in nums:
      one = one^num&~two
      two = two^num&~one
    return one
```

